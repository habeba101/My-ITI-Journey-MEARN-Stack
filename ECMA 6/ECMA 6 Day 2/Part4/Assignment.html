<!doctype html>
<html lang="en">
  <head>
    <title>Explanation</title>
  </head>
  <body>
    <p>Set and Map Objects</p>
    <p>Iterator and Generator</p>
    <p>Proxy Object</p>
  </body>
  <script>
    // Set: Stores a collection of unique values with no duplicates.
    //Stores only distinct values.
    // Commonly used to remove duplicates from other data structures.

    let setValues = new Set();
    setValues.add("Habeba");
    setValues.add(26);
    setValues.add("habebaahmed101@gmail.com");
    //trying duplicates
    setValues.add("habebaahmed101@gmail.com");
    setValues.add("habebaahmed101@gmail.com");
    // setValues.forEach(function (elm) {
    //   console.log(elm);
    // });
    console.log(setValues.values());
    console.log(setValues.entries());
    console.log(setValues.has("Habeba"));
    setValues.delete("habebaahmed101@gmail.com");
    console.log(setValues);

    // Map: Stores data as keyâ€“value pairs, allowing efficient lookup by keys.
    // Keys can be of any data type.
    // Maintains insertion order for entries.

    let mapVals = new Map();
    mapVals.set("name", "Habeba");
    mapVals.set("age", 26);
    mapVals.set("email", "habebaahmed101@gmail.com");
    console.log(mapVals.size);
    console.log(mapVals);
    console.log(mapVals.get("name"));
    console.log("---------------------------");
    console.log("using for each");
    mapVals.forEach((element) => {
      console.log(element);
    });
    console.log("---------------------------");

    for (let i of mapVals) {
      console.log(`key: ${i[0]} item: ${i[1]}`);
    }
    console.log("---------------------------");
    mapVals.delete("name");
    for (let i of mapVals) {
      console.log(`key: ${i[0]} item: ${i[1]}`);
    }
    console.log(mapVals.entries());
    console.log(mapVals.keys());
    console.log(mapVals.values());
    mapVals.clear();
    console.log(mapVals);

    //iterator and generator
    //Iyerator is an object that follows a specific protocol and allows you to iterate over a sequence of values one at a time
    //it implements the itertaor protocol by having next method that returns an object with two properities (value, done)
    // it is done manually

    function makeRangeIterator(start = 0, end = Infinity, step = 1) {
      let nextIndex = start;
      let iterationCount = 0;

      const rangeIterator = {
        next() {
          let result;
          if (nextIndex < end) {
            result = { value: nextIndex, done: false };
            nextIndex += step;
            iterationCount++;
            return result;
          }
          return { value: iterationCount, done: true };
        },
      };
      return rangeIterator;
    }

    const iter = makeRangeIterator(1, 10, 1);

    let result = iter.next();
    while (!result.done) {
      console.log(result.value);
      result = iter.next();
    }

    console.log("Iterated over sequence of size:", result.value);
    //Generators :While custom iterators are a useful tool, their creation requires careful programming due to the need to explicitly maintain their internal state. Generator functions provide a powerful alternative: they allow you to define an iterative algorithm by writing a single function whose execution is not continuous. Generator functions are written using the function* syntax.

    // When called, generator functions do not initially execute their code. Instead, they return a special type of iterator, called a Generator. When a value is consumed by calling the generator's next method, the Generator function executes until it encounters the yield keyword.

    // The function can be called as many times as desired, and returns a new Generator each time. Each Generator may only be iterated once.
    function* makeRangeIterator(start = 0, end = Infinity, step = 1) {
      let iterationCount = 0;
      for (let i = start; i < end; i += step) {
        iterationCount++;
        yield i;
      }
      return iterationCount;
    }

    //Iterables
    //An object is iterable if it defines its iteration behavior, such as what values are looped over in a for...of construct. Some built-in types, such as Array or Map, have a default iteration behavior, while other types (such as Object) do not.

    // In order to be iterable, an object must implement the [Symbol.iterator]() method. This means that the object (or one of the objects up its prototype chain) must have a property with a Symbol.iterator key.

    // It may be possible to iterate over an iterable more than once, or only once. It is up to the programmer to know which is the case.
    const range = {
      from: 1,
      to: 8,

      [Symbol.iterator]() {
        let current = this.from;
        let end = this.to;

        return {
          next() {
            if (current <= end) {
              return { value: current++, done: false };
            }
            return { done: true };
          },
        };
      },
    };
    for (const value of range) console.log(value);

    //proxy Object

    // The Proxy object allows you to create an object that can be used in place of the original object, but which may redefine fundamental Object operations like getting, setting, and defining properties. Proxy objects are commonly used to log property accesses, validate, format, or sanitize inputs, and so on.
    // You create a Proxy with two parameters:
    // target: the original object which you want to proxy
    // handler: an object that defines which operations will be intercepted and how to redefine intercepted operations.
    const target = {
      message1: "hello",
      message2: "everyone",
    };

    const handler1 = {};

    const proxy1 = new Proxy(target, handler1);
    console.log(proxy1.message1); // hello
    console.log(proxy1.message2); // everyone

    // reflect performs the operation on the original (target) object.
    // The proxy has no data.
    // All data is inside the original object (target).
    // Proxy is only a controller in front of it.
    // Reflect is the correct way to talk to the real object
    const user = { name: "Habeba" };
    const proxy = new Proxy(user, {
      set(target, prop, value) {
        Reflect.set(target, prop, value);
        return true;
      },
    });

    proxy.name = "Ahmed";

    console.log(user.name);
  </script>
</html>
